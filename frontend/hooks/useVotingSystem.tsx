"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at 
  <root>/scripts/genabi.mjs. This script parses the 
  <root>/backend/deployments directory to retrieve 
  deployment information for VotingSystem.sol:
  
  - <root>/frontend/abi/VotingSystemABI.ts
  - <root>/frontend/abi/VotingSystemAddresses.ts
*/
// @ts-ignore - These files are generated at build time
import { VotingSystemAddresses } from "@/abi/VotingSystemAddresses";
// @ts-ignore - These files are generated at build time
import { VotingSystemABI } from "@/abi/VotingSystemABI";

type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type VotingSystemInfoType = {
  abi: any[];
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

type ProposalInfo = {
  description: string;
  startTime: bigint;
  endTime: bigint;
  isActive: boolean;
};

function getVotingSystemByChainId(
  chainId: number | undefined
): VotingSystemInfoType {
  if (!chainId) {
    return { abi: (VotingSystemABI?.abi || []) as unknown as any[] };
  }

  try {
    const entry =
      VotingSystemAddresses?.[chainId.toString() as keyof typeof VotingSystemAddresses];

    if (!entry || entry.address === ethers.ZeroAddress) {
      return { abi: (VotingSystemABI?.abi || []) as unknown as any[], chainId };
    }

    return {
      address: entry?.address as `0x${string}` | undefined,
      chainId: entry?.chainId ?? chainId,
      chainName: entry?.chainName,
      abi: (VotingSystemABI?.abi || []) as unknown as any[],
    };
  } catch {
    // ABI files not generated yet
    return { abi: [], chainId };
  }
}

export const useVotingSystem = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  const [proposals, setProposals] = useState<ProposalInfo[]>([]);
  const [selectedProposalId, setSelectedProposalId] = useState<number | undefined>(undefined);
  const [proposalCount, setProposalCount] = useState<bigint>(BigInt(0));
  const [hasVoted, setHasVoted] = useState<boolean>(false);
  
  // Encrypted result handles
  const [approveHandle, setApproveHandle] = useState<string | undefined>(undefined);
  const [rejectHandle, setRejectHandle] = useState<string | undefined>(undefined);
  const [abstainHandle, setAbstainHandle] = useState<string | undefined>(undefined);
  const [totalWeightHandle, setTotalWeightHandle] = useState<string | undefined>(undefined);
  
  // Decrypted results
  const [clearApprove, setClearApprove] = useState<ClearValueType | undefined>(undefined);
  const [clearReject, setClearReject] = useState<ClearValueType | undefined>(undefined);
  const [clearAbstain, setClearAbstain] = useState<ClearValueType | undefined>(undefined);
  const [clearTotalWeight, setClearTotalWeight] = useState<ClearValueType | undefined>(undefined);
  
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [isCreatingProposal, setIsCreatingProposal] = useState<boolean>(false);
  const [isSettingWeight, setIsSettingWeight] = useState<boolean>(false);
  const [userWeight, setUserWeight] = useState<bigint | undefined>(undefined);
  const [message, setMessage] = useState<string>("");

  const votingSystemRef = useRef<VotingSystemInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isSubmittingRef = useRef<boolean>(isSubmitting);

  const votingSystem = useMemo(() => {
    const c = getVotingSystemByChainId(chainId);
    votingSystemRef.current = c;
    // Only show error message if chainId is defined but no address is found
    // Don't show error if chainId is undefined (still loading) or if address exists
    if (chainId !== undefined && !c.address) {
      setMessage(`The voting contract is not deployed on this network (Chain ID: ${chainId}). Please deploy the contract first.`);
    } else if (c.address) {
      // Clear message if contract address is found
      setMessage("");
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!votingSystem) {
      return undefined;
    }
    return Boolean(votingSystem.address && votingSystem.address !== ethers.ZeroAddress);
  }, [votingSystem]);

  const refreshProposals = useCallback(async () => {
    if (isRefreshingRef.current) {
      return;
    }

    if (!votingSystem.address || !ethersReadonlyProvider) {
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    try {
      const contract = new ethers.Contract(
        votingSystem.address,
        votingSystem.abi,
        ethersReadonlyProvider
      );

      const count = await contract.proposalCount();
      setProposalCount(count);

      const proposalList: ProposalInfo[] = [];
      for (let i = 0; i < Number(count); i++) {
        const proposal = await contract.getProposal(i);
        proposalList.push({
          description: proposal.description,
          startTime: proposal.startTime,
          endTime: proposal.endTime,
          isActive: proposal.isActive,
        });
      }
      setProposals(proposalList);
    } catch (e) {
      setMessage(`Unable to load proposals. Please try again later.`);
    } finally {
      isRefreshingRef.current = false;
      setIsRefreshing(false);
    }
  }, [votingSystem.address, votingSystem.abi, ethersReadonlyProvider]);

  const refreshResults = useCallback(async () => {
    if (!votingSystem.address || !ethersReadonlyProvider || selectedProposalId === undefined) {
      return;
    }

    try {
      const contract = new ethers.Contract(
        votingSystem.address,
        votingSystem.abi,
        ethersReadonlyProvider
      );

      const [approve, reject, abstain, totalWeight] = await Promise.all([
        contract.getEncryptedApproveTotal(selectedProposalId),
        contract.getEncryptedRejectTotal(selectedProposalId),
        contract.getEncryptedAbstainTotal(selectedProposalId),
        contract.getEncryptedTotalWeight(selectedProposalId),
      ]);

      setApproveHandle(approve);
      setRejectHandle(reject);
      setAbstainHandle(abstain);
      setTotalWeightHandle(totalWeight);
    } catch (e) {
      setMessage(`Unable to load voting results. Please try again later.`);
    }
  }, [votingSystem.address, votingSystem.abi, ethersReadonlyProvider, selectedProposalId]);

  const checkHasVoted = useCallback(async () => {
    if (!votingSystem.address || !ethersReadonlyProvider || selectedProposalId === undefined || !ethersSigner) {
      return;
    }

    try {
      const contract = new ethers.Contract(
        votingSystem.address,
        votingSystem.abi,
        ethersReadonlyProvider
      );

      const userAddress = await ethersSigner.getAddress();
      const voted = await contract.checkHasVoted(selectedProposalId, userAddress);
      setHasVoted(voted);
    } catch (e) {
      setMessage(`Unable to check your vote status. Please try again.`);
    }
  }, [votingSystem.address, votingSystem.abi, ethersReadonlyProvider, selectedProposalId, ethersSigner]);

  const refreshUserWeight = useCallback(async () => {
    if (!votingSystem.address || !ethersReadonlyProvider || !ethersSigner) {
      return;
    }

    try {
      const contract = new ethers.Contract(
        votingSystem.address,
        votingSystem.abi,
        ethersReadonlyProvider
      );

      const userAddress = await ethersSigner.getAddress();
      const weight = await contract.getUserWeight(userAddress);
      setUserWeight(weight);
    } catch (e) {
      setMessage(`Unable to load your voting weight. Please try again.`);
    }
  }, [votingSystem.address, votingSystem.abi, ethersReadonlyProvider, ethersSigner]);

  const setUserWeightForAddress = useCallback(
    async (userAddress: string, weight: number) => {
      if (isSettingWeight || !votingSystem.address || !ethersSigner) {
        return;
      }

      setIsSettingWeight(true);
      setMessage("Setting user weight...");

      try {
        const contract = new ethers.Contract(
          votingSystem.address,
          votingSystem.abi,
          ethersSigner
        );

        const tx = await contract.setUserWeight(userAddress, weight);
        setMessage(`Waiting for transaction: ${tx.hash}...`);

        const receipt = await tx.wait();
        setMessage(`User voting weight has been successfully updated.`);

        // Refresh user weight if it's the current user
        const currentAddress = await ethersSigner.getAddress();
        if (userAddress.toLowerCase() === currentAddress.toLowerCase()) {
          await refreshUserWeight();
        }
      } catch (e: any) {
        setMessage(`Unable to set user weight. Please check the address and try again.`);
      } finally {
        setIsSettingWeight(false);
      }
    },
    [votingSystem.address, votingSystem.abi, ethersSigner, refreshUserWeight]
  );

  useEffect(() => {
    refreshProposals();
    refreshUserWeight();
  }, [refreshProposals, refreshUserWeight]);

  useEffect(() => {
    if (selectedProposalId !== undefined) {
      refreshResults();
      checkHasVoted();
    }
  }, [selectedProposalId, refreshResults, checkHasVoted]);

  const submitVote = useCallback(
    async (choice: number) => {
      if (isSubmittingRef.current || !votingSystem.address || !instance || !ethersSigner || selectedProposalId === undefined) {
        return;
      }

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage("Encrypting vote...");

      try {
        const contract = new ethers.Contract(
          votingSystem.address,
          votingSystem.abi,
          ethersSigner
        );

        // Create encrypted input for choice only (weight is handled by contract)
        const input = instance.createEncryptedInput(
          votingSystem.address,
          ethersSigner.address
        );
        input.add32(choice);

        const enc = await input.encrypt();

        setMessage("Submitting vote...");

        const tx = await contract.submitVote(
          selectedProposalId,
          enc.handles[0], // choice
          enc.inputProof
        );

        setMessage(`Waiting for transaction: ${tx.hash}...`);

        const receipt = await tx.wait();
        setMessage(`Your encrypted vote has been successfully submitted.`);

        // Refresh after voting
        await refreshResults();
        await checkHasVoted();
      } catch (e: any) {
        setMessage(`Unable to submit your vote. Please ensure the proposal is active and try again.`);
      } finally {
        isSubmittingRef.current = false;
        setIsSubmitting(false);
      }
    },
    [votingSystem.address, votingSystem.abi, instance, ethersSigner, selectedProposalId, refreshResults, checkHasVoted]
  );

  const decryptResults = useCallback(async () => {
    if (isDecryptingRef.current || !votingSystem.address || !instance || !ethersSigner) {
      return;
    }

    if (!approveHandle || !rejectHandle || !abstainHandle || !totalWeightHandle) {
      setMessage("No voting results available to decrypt. Please wait for votes to be submitted.");
      return;
    }

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Decrypting results...");

    try {
      const sig: FhevmDecryptionSignature | null =
        await FhevmDecryptionSignature.loadOrSign(
          instance,
          [votingSystem.address as `0x${string}`],
          ethersSigner,
          fhevmDecryptionSignatureStorage
        );

      if (!sig) {
        setMessage("Unable to create decryption signature. Please ensure your wallet is connected and try again.");
        return;
      }

      const results = await instance.userDecrypt(
        [
          { handle: approveHandle, contractAddress: votingSystem.address },
          { handle: rejectHandle, contractAddress: votingSystem.address },
          { handle: abstainHandle, contractAddress: votingSystem.address },
          { handle: totalWeightHandle, contractAddress: votingSystem.address },
        ],
        sig.privateKey,
        sig.publicKey,
        sig.signature,
        sig.contractAddresses,
        sig.userAddress,
        sig.startTimestamp,
        sig.durationDays
      );

      setClearApprove({ handle: approveHandle, clear: results[approveHandle] });
      setClearReject({ handle: rejectHandle, clear: results[rejectHandle] });
      setClearAbstain({ handle: abstainHandle, clear: results[abstainHandle] });
      setClearTotalWeight({ handle: totalWeightHandle, clear: results[totalWeightHandle] });

      setMessage("Voting results have been successfully decrypted and are now visible.");
    } catch (e: any) {
        setMessage(`Unable to decrypt results. Please ensure your wallet is connected and try again.`);
    } finally {
      isDecryptingRef.current = false;
      setIsDecrypting(false);
    }
  }, [
    votingSystem.address,
    instance,
    ethersSigner,
    approveHandle,
    rejectHandle,
    abstainHandle,
    totalWeightHandle,
    fhevmDecryptionSignatureStorage,
  ]);

  const createProposal = useCallback(
    async (description: string, duration: number) => {
      if (isCreatingProposal || !votingSystem.address || !ethersSigner) {
        return;
      }

      setIsCreatingProposal(true);
      setMessage("Creating proposal...");

      try {
        const contract = new ethers.Contract(
          votingSystem.address,
          votingSystem.abi,
          ethersSigner
        );

        const tx = await contract.createProposal(description, duration);
        setMessage(`Waiting for transaction: ${tx.hash}...`);

        const receipt = await tx.wait();
        setMessage(`New proposal has been successfully created and is now active.`);

        await refreshProposals();
      } catch (e: any) {
        setMessage(`Unable to create proposal. Please check your inputs and try again.`);
      } finally {
        setIsCreatingProposal(false);
      }
    },
    [votingSystem.address, votingSystem.abi, ethersSigner, refreshProposals]
  );

  return {
    contractAddress: votingSystem.address,
    abi: votingSystem.abi,
    isDeployed,
    proposals,
    proposalCount,
    selectedProposalId,
    setSelectedProposalId,
    hasVoted,
    approveHandle,
    rejectHandle,
    abstainHandle,
    totalWeightHandle,
    clearApprove,
    clearReject,
    clearAbstain,
    clearTotalWeight,
    isRefreshing,
    isDecrypting,
    isSubmitting,
    isCreatingProposal,
    isSettingWeight,
    userWeight,
    message,
    refreshProposals,
    refreshResults,
    submitVote,
    decryptResults,
    createProposal,
    checkHasVoted,
    setUserWeightForAddress,
    refreshUserWeight,
  };
};

